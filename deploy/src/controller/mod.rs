use std::error::Error;
use std::fmt::Debug;
use std::hash::Hash;
use std::sync::Arc;

use async_trait::async_trait;
use futures::StreamExt;
use kube::runtime::controller::Action;
use kube::runtime::watcher::Config as WatcherConfig;
use kube::{Api, Resource};
use serde::de::DeserializeOwned;

use crate::controller::consts::DEFAULT_REQUEUE_DURATION;

/// CRD `XlineCluster` controller
pub(crate) mod cluster;
/// CRD constants
mod consts;

/// A Resource controlled by a controller
pub(crate) trait Controlled:
    Resource + DeserializeOwned + Clone + Debug + Sync + Send + 'static
where
    Self::DynamicType: Hash + Eq + Clone + Default + Unpin + Debug,
{
    /// Which controller type control this resource
    type Owner: Controller<Self>;
}

/// The common context
pub(crate) struct Context<C> {
    /// The controller held by this context
    controller: C,
}

impl<C> Context<C> {
    /// Constructor
    pub(crate) fn new(controller: C) -> Self {
        Self { controller }
    }
}

/// The controller
#[async_trait]
pub(crate) trait Controller<R>: Sized + Send + Sync + 'static
where
    R: Resource + DeserializeOwned + Clone + Debug + Sync + Send + 'static,
    R::DynamicType: Hash + Eq + Clone + Default + Unpin + Debug,
{
    /// The error generated by this controller
    type Error: Error + Send + Sync + 'static;

    /// Return the kubernetes resource api
    fn api(&self) -> &Api<R>;

    /// Use &self to execute a reconcile
    async fn reconcile_once(&self, resource: &Arc<R>) -> Result<(), Self::Error>;

    /// User &self to handle error
    fn handle_error(&self, resource: &Arc<R>, err: &Self::Error);

    /// The reconcile function used in kube::runtime::Controller
    async fn reconcile(resource: Arc<R>, ctx: Arc<Context<Self>>) -> Result<Action, Self::Error> {
        let controller = &ctx.controller;
        controller.reconcile_once(&resource).await?;
        Ok(Action::requeue(DEFAULT_REQUEUE_DURATION))
    }

    /// The on_error function used in kube::runtime::Controller
    fn on_error(resource: Arc<R>, err: &Self::Error, ctx: Arc<Context<Self>>) -> Action {
        let controller = &ctx.controller;
        controller.handle_error(&resource, err);
        Action::requeue(DEFAULT_REQUEUE_DURATION)
    }

    /// Run this controller
    async fn run(ctx: Arc<Context<Self>>) {
        let controller = &ctx.controller;
        let api = controller.api().clone();
        kube::runtime::Controller::new(api, WatcherConfig::default())
            .shutdown_on_signal()
            .run(Self::reconcile, Self::on_error, ctx)
            .filter_map(|res| async move { res.ok() })
            .for_each(|_| futures::future::ready(()))
            .await;
    }
}
