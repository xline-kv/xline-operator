use std::error::Error;
use std::fmt::Debug;
use std::hash::Hash;
use std::sync::Arc;

use async_trait::async_trait;
use futures::StreamExt;
use kube::runtime::controller::Action;
use kube::runtime::watcher::Config as WatcherConfig;
use kube::{Api, Resource};
use serde::de::DeserializeOwned;

use crate::consts::DEFAULT_REQUEUE_DURATION;

/// Cluster controller
pub(crate) mod cluster;

/// The common context
pub(crate) struct Context<C> {
    /// The controller held by this context
    controller: C,
}

impl<C> Context<C> {
    /// Constructor
    pub(crate) fn new(controller: C) -> Self {
        Self { controller }
    }
}

/// Metrics labeled
pub(crate) trait MetricsLabeled {
    /// Label
    #[allow(clippy::indexing_slicing)] // labels should always have at least one element
    fn label(&self) -> &str {
        self.labels()[0]
    }

    /// Labels
    fn labels(&self) -> Vec<&str>;
}

/// The common metrics shared by all controllers
pub(crate) trait Metrics: Default {
    /// Register metrics
    fn register(&self, registry: &prometheus::Registry) -> Result<(), prometheus::Error>;

    /// Record duration
    fn record_duration(&self) -> prometheus::HistogramTimer;

    /// Record failed count
    fn record_failed_count(&self, labels: &[&str]);
}

/// The controller
#[async_trait]
pub(crate) trait Controller<R>: Sized + Send + Sync + 'static
where
    R: Resource + DeserializeOwned + Clone + Debug + Sync + Send + 'static,
    R::DynamicType: Hash + Eq + Clone + Default + Unpin + Debug,
{
    /// The error generated by this controller
    type Error: MetricsLabeled + Error + Send + Sync + 'static;

    /// The metrics used by this controller
    type Metrics: Metrics;

    /// Get the metrics
    fn metrics(&self) -> &Self::Metrics;

    /// Use &self to execute a reconcile
    async fn reconcile_once(&self, resource: &Arc<R>) -> Result<(), Self::Error>;

    /// User &self to handle error
    fn handle_error(&self, resource: &Arc<R>, err: &Self::Error);

    /// The reconcile function used in kube::runtime::Controller
    async fn reconcile(resource: Arc<R>, ctx: Arc<Context<Self>>) -> Result<Action, Self::Error> {
        let controller = &ctx.controller;
        let _timer = controller.metrics().record_duration();
        controller.reconcile_once(&resource).await?;
        Ok(Action::requeue(DEFAULT_REQUEUE_DURATION))
    }

    /// The on_error function used in kube::runtime::Controller
    fn on_error(resource: Arc<R>, err: &Self::Error, ctx: Arc<Context<Self>>) -> Action {
        let controller = &ctx.controller;
        controller.metrics().record_failed_count(&err.labels());
        controller.handle_error(&resource, err);
        Action::requeue(DEFAULT_REQUEUE_DURATION)
    }

    /// Run this controller
    async fn run(ctx: Arc<Context<Self>>, api: Api<R>) {
        kube::runtime::Controller::new(api, WatcherConfig::default())
            .shutdown_on_signal()
            .run(Self::reconcile, Self::on_error, ctx)
            .filter_map(|res| async move { res.ok() })
            .for_each(|_| futures::future::ready(()))
            .await;
    }
}
